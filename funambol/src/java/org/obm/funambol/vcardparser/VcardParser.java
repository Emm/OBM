/* Generated By:JavaCC: Do not edit this line. VcardParser.java */
package org.obm.funambol.vcardparser;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.TimeZone;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.net.QuotedPrintableCodec;

import com.funambol.common.pim.common.FieldsList;
import com.funambol.common.pim.common.ParamList;
import com.funambol.common.pim.common.Property;
import com.funambol.common.pim.common.XTag;
import com.funambol.common.pim.contact.Contact;
import com.funambol.common.pim.contact.Email;
import com.funambol.common.pim.contact.Note;
import com.funambol.common.pim.contact.Phone;
import com.funambol.common.pim.contact.Title;
import com.funambol.common.pim.contact.WebPage;
import com.funambol.common.pim.utility.TimeUtils;


/**
 * This class parses an input file formatted according to
 * versit vCard 2.1 specification and generates an object model of the contact
 * using the package com.funambol.pdi.contact
 *
 * @see Contact
 * @version $Id: VCardParser.jj,v 1.7 2008-08-26 15:51:24 luigiafassina Exp $
 */
public class VcardParser implements VcardParserConstants {

    private static final String DEFAULT_CHARSET =
        new OutputStreamWriter(new ByteArrayOutputStream()).getEncoding();

    // Encoding the QuotedPrintable HERE in the VCARD parser.
    // That way the Contact instances are 'clean'.
    private QuotedPrintableCodec qp = new QuotedPrintableCodec();

    private Contact contact;

    private int cellTel        = 0;
    private int cellHomeTel    = 0;
    private int cellWorkTel    = 0;
    private int voiceTel       = 0;
    private int voiceHomeTel   = 0;
    private int voiceWorkTel   = 0;
    private int fax            = 0;
    private int faxHome        = 0;
    private int faxWork        = 0;
    private int car            = 0;
    private int pager          = 0;
    private int primary        = 0;
    private int companyMain    = 0;

    // the email
    private int email          = 0;
    private int emailHome      = 0;
    private int emailWork      = 0;

    // the body
    private int note           = 0;

    // the web page
    private int webPage        = 0;
    private int webPageHome    = 0;
    private int webPageWork    = 0;

    // the job title
    private int title          = 0;

    // the addresses
    private int addressHome    = 0;
    private int addressWork    = 0;
    private int addressOther   = 0;

    // the default timezone to use if datetimes are not UTC
    // if null, no conversion is performed
    //
    private TimeZone defaultTimeZone = null;

    //
    // the default charset to use if some properties are encoded
    // but without the charset
    //
    private String defaultCharset = DEFAULT_CHARSET;

    /**
     * Constructor to create a parser specifying:
     * <ul>
     * <li>a default time zone to be used
     * if datetimes are not in UTC. If tz is null, no conversion will be
     * performed</li>
     * <li>a default charset to use if some properties are encoded
     * but without the charset</li>
     * </ul>
     *
     * @param tz the default time zone
     */
    public VcardParser(InputStream is, String tz, String defaultCharset) {
        this(is);

        if (tz != null) {
            defaultTimeZone = TimeZone.getTimeZone(tz);
        }
        if (defaultCharset != null) {
            this.defaultCharset = defaultCharset;
        }
    }

    /**
     * Sets the parameters encoding, charset, language, value for a given property
     * fetching them from the given ParamList.
     * Notice that if the items are not set (i.e. are null) in the ParamList, they
     * will be set to null in the property too (this is to avoid inconsistency when
     * the same vCard property is encountered more than one time, and thus overwritten
     * in the Contact object model).
     */
    private void setParameters(Property property, ParamList plist) {
        if (plist != null) {
            property.setEncoding(plist.getEncoding());
            property.setCharset (plist.getCharset());
            property.setLanguage(plist.getLanguage());
            property.setValue   (plist.getValue   ());
            property.setXParams (plist.getXParams ());
        }
    }

    /**
     * Sets the parameters encoding, charset, language, value and group for a given property
     * fetching them from the given ParamList and the group Token.
     */
    private void setParameters(Property property, ParamList plist, Token group) {
        if (!(group==null)) {
            property.setGroup(group.image);
        }
        else {
            property.setGroup(null);
        }
        setParameters(property,plist);
    }

    /**
     * Unfolds a string (i.e. removes all the CRLF characters)
     */
    private String unfold (String str) {
        int ind = str.indexOf("\r\n");
        if (ind == -1) {
            return unfoldNewline(str);
        }
        else {
            String tmpString1 = str.substring(0,ind);
            String tmpString2 = str.substring(ind+2);
            return unfoldNewline(unfold(tmpString1+tmpString2));
        }
    }

    /**
     * Unfolds a string (i.e. removes all the line break characters).
     * This function is meant to ensure compatibility with vCard documents
     * that adhere loosely to the specification
     */
    private String unfoldNewline (String str) {
        int ind = str.indexOf("\n");
        if (ind == -1) {
            return str;
        }
        else {
            String tmpString1 = str.substring(0,ind);
            String tmpString2 = str.substring(ind+1);
            return unfoldNewline(tmpString1+tmpString2);
        }
    }

    /**
     * Decode the given text according to the given encoding and charset
     *
     * @param text the text to decode
     * @param encoding the encoding
     * @param propertyCharset the charset
     *
     * @return the text decoded
     */
    private String decode(String text, String encoding, String propertyCharset)
    throws ParseException {
        if (text == null) {
            return null;
        }

        //
        // If input charset is null then set it with default charset
        //
        if (propertyCharset == null) {
            propertyCharset = defaultCharset; // we use the default charset
        }
        if (encoding != null) {
            if ("QUOTED-PRINTABLE".equals(encoding)) {
                try {
                    //
                    // Some phone, like the Sony Ericsson k750i can send something
                    // like that:
                    //
                    // BEGIN:VCARD
                    // VERSION:2.1
                    // N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;=C3=85=C3=A5=C3=A6
                    // TITLE;CHARSET=UTF-8:Title
                    // ORG;CHARSET=UTF-8:Compan
                    // TEL;CELL:0788554422
                    // EMAIL;INTERNET;PREF;CHARSET=UTF-8:ac0@dagk.com
                    // ADR;HOME;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;;S=CE=A6;City;Stat;6;Peru=
                    //
                    // X-IRMC-LUID:000200000102
                    // END:VCARD
                    //
                    // At the end of the address there is a '=\r\n\r\n'. This is replaced
                    // with '=\r\n' by SourceUtils.handleDelimiting so here the vcard is:
                    //
                    // BEGIN:VCARD
                    // VERSION:2.1
                    // N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;=C3=85=C3=A5=C3=A6
                    // TITLE;CHARSET=UTF-8:Title
                    // ORG;CHARSET=UTF-8:Compan
                    // TEL;CELL:0788554422
                    // EMAIL;INTERNET;PREF;CHARSET=UTF-8:ac0@dagk.com
                    // ADR;HOME;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;;S=CE=A6;City;Stat;6;Peru=
                    // X-IRMC-LUID:000200000102
                    // END:VCARD
                    //
                    // The problem is with the address becasue the value is in QP but
                    // it finishes with a '=' so this is not a valid QP
                    // (Invalid quoted-printable encoding)
                    // To fix the problem, before to decode the string, we remove the
                    // '=' at the end of the string
                    //
                    text = removeLastEquals(text);

                    return qp.decode(text, propertyCharset);
                } catch (DecoderException de) {
                    throw new ParseException(de.getMessage());
                } catch (UnsupportedEncodingException ue) {
                    throw new ParseException(ue.getMessage());
                }
            }
        } else {
            try {
                return new String(text.getBytes(), propertyCharset);
            } catch (UnsupportedEncodingException ue) {
                throw new ParseException(ue.getMessage());
            }
        }

        return text;
    }

    /**
     * Removes the last equals from the end of the given String
     */
    private String removeLastEquals(String data) {
        if (data == null) {
            return data;
        }
        data = data.trim();
        while (data.endsWith("=")) {
            data = data.substring(0, data.length() - 1);
        }
        return data;
    }

    /**
     * Unescape backslash and semicolon.
     *
     * @param text the text to unescape
     * @return String the unescaped text
     */
    private String unescape(String text) {

        if (text == null) {
            return text;
        }

        StringBuffer value = new StringBuffer();
        int length = text.length();
        boolean foundSlash = false;
        for (int i=0; i<length; i++) {
            char ch = text.charAt(i);
            switch (ch) {
                case '\\':
                    if (foundSlash) {
                        foundSlash = false;
                        value.append('\\');
                    } else {
                        foundSlash = true;
                    }
                    break;
                case ';':
                    value.append(';');
                    foundSlash = false;
                    break;
                default:
                    if (foundSlash) {
                        foundSlash = false;
                        value.append('\\');
                    }
                    value.append(ch);
                    break;
            }
        }
        return value.toString();
    }

    public static void main(String args[]) {
        StringBuffer vCard=new StringBuffer();
        String line;
        try {
            BufferedReader reader=new BufferedReader(
                                      new InputStreamReader(System.in));
            line=reader.readLine();
            while (line!=null){
                vCard.append(line+"\r\n");
                line=reader.readLine();
            }
            System.out.println(vCard);
            ByteArrayInputStream buffer;
            VcardParser parser;
            buffer = new ByteArrayInputStream(vCard.toString().getBytes());
            parser = new VcardParser(buffer, null, "UTF-8");
            parser.vCard();
            System.out.println("vcard file parsed successfully.");
        } catch (ParseException e) {
            System.out.println("vcard file failed to parse.");
            System.out.println(e.toString());
        }catch (IOException ioe){
            System.out.println("IO Exception: "+ioe.getMessage());
        }
    }
    // This equal to the grammar parsing rule, but javacc is not able
    // to use equal names rules with different arguments as in java.
    final public Contact vCard() throws ParseException {
        return vCard(new Contact());
    }

  final public Contact vCard(Contact vCard) throws ParseException {
    contact = vCard;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
      case WS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        jj_consume_token(EOL);
        break;
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(VCBEGIN);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
      case WS:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        jj_consume_token(EOL);
        break;
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_3:
    while (true) {
      content();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATEGORIES:
      case VERSION:
      case TITLE:
      case NICKNAME:
      case EMAIL:
      case FN:
      case ORG:
      case BDAY:
      case PHOTO:
      case ADR:
      case UID:
      case LABEL:
      case ROLE:
      case TZ:
      case LOGO:
      case NOTE:
      case URL:
      case N:
      case REV:
      case TEL:
      case FOLDER:
      case EXTENSION:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(VCEND);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
      case WS:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        jj_consume_token(EOL);
        break;
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
        {if (true) return contact;}
    throw new Error("Missing return statement in function");
  }

  final public void content() throws ParseException {
 Token group=null;
    if (jj_2_1(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        group = jj_consume_token(IDENTIFIER);
        jj_consume_token(1);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      property(group);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        notImplemented();
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

// All properties we do not implement, but are willing to parse.
// We simply ignore them as allowed by the standard.
  final public void notImplemented() throws ParseException {
    Token identifier;
    identifier = jj_consume_token(IDENTIFIER);
    params();
    colon();
    text();
    jj_consume_token(EOL);

  }

  final public void property(Token group) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VERSION:
      version();
      break;
    case TITLE:
      title(group);
      break;
    case N:
      name(group);
      break;
    case EMAIL:
      mail(group);
      break;
    case TEL:
      tel(group);
      break;
    case FN:
      fname(group);
      break;
    case ORG:
      organization(group);
      break;
    case ADR:
      address(group);
      break;
    case ROLE:
      role(group);
      break;
    case URL:
      url(group);
      break;
    case REV:
      rev(group);
      break;
    case NICKNAME:
      nickname(group);
      break;
    case BDAY:
      birthday(group);
      break;
    case LABEL:
      label(group);
      break;
    case TZ:
      timezone(group);
      break;
    case LOGO:
      logo(group);
      break;
    case NOTE:
      note(group);
      break;
    case UID:
      uid(group);
      break;
    case PHOTO:
      photo(group);
      break;
    case FOLDER:
      folder(group);
      break;
    case EXTENSION:
      extension(group);
      break;
    case CATEGORIES:
      categories(group);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void categories(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(CATEGORIES);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.getCategories().setPropertyValue(text);
        setParameters(contact.getCategories(), plist, group);
  }

  final public void extension(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    Token xtagName  = null;
    xtagName = jj_consume_token(EXTENSION);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        XTag tmpxTag = new XTag();
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        tmpxTag.getXTag().setPropertyValue(text);
        setParameters(tmpxTag.getXTag(), plist, group);

        tmpxTag.setXTagValue(xtagName.image);
        contact.addXTag(tmpxTag);
  }

  final public void version() throws ParseException {
 Token ver;
    jj_consume_token(VERSION);
    params();
    colon();
    ver = jj_consume_token(CONTENTSTRING);
    jj_consume_token(EOL);
        if (!(ver.image.equals("2.1")) && !(ver.image.equals("3.0"))) {
            {if (true) throw new ParseException("Encountered a vCard version other than 2.1 or 3.0 ("+ver.image+")");}
        }
  }

  final public void title(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(TITLE);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text = unescape(text);
        Title tmptitle = new Title(text);
        setParameters(tmptitle, plist, group);

        if (title == 0) {
            if (contact.getBusinessDetail().getTitles() == null) {
                contact.getBusinessDetail().setTitles(new ArrayList());
            }
            tmptitle.setTitleType("JobTitle");
        } else {
            tmptitle.setTitleType("JobTitle" + (title + 1));
        }
        contact.getBusinessDetail().addTitle(tmptitle);
        title++;
  }

  final public void mail(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(EMAIL);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        //
        // NOTE: The email in outlook are email1address, email2address, email3address.
        // So the first INTERNET mail is email1address and the other INTERNET
        // are labeled as OtherEmail2address, otherEmail3Address...
        // The first INTERNET;HOME email is Email2Address, and the other are HomeEmail2Address....
        // The INTERNET;HOME;X-FUNAMBOL-INSTANTMESSENGER email is IMAddress.
        // The first INTERNET;WORK email is Email3Address, and the other are BusinessEmail2Address....
        // If there is not specify the email's type then consider the email like
        // Email1Address and the other are OtherEmail2Address...
        //
        if ( plist.getSize() == 0                                       ||
            (plist.getSize() == 1 && plist.containsKey("INTERNET"))     ||
            (plist.containsKey("PREF") && plist.containsKey("INTERNET"))
        ) {
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            Email tmpmail = new Email(text);
            setParameters(tmpmail,plist,group);
            if (email == 0) {
                if (emailHome == 0) {
                    if (contact.getPersonalDetail().getEmails() == null) {
                        contact.getPersonalDetail().setEmails(new ArrayList());
                    }
                }
                tmpmail.setEmailType("Email1Address");
            } else {
                tmpmail.setEmailType("OtherEmail" + (email + 1) + "Address");
            }
            contact.getPersonalDetail().addEmail(tmpmail);
            email++;
        } else if (plist.containsKey("HOME")) {

            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            Email tmpmail = new Email(text);
            setParameters(tmpmail,plist,group);

            if (plist.getXParams().containsKey("X-FUNAMBOL-INSTANTMESSENGER")) {
                if (email == 0) {
                    if (contact.getPersonalDetail().getEmails() == null) {
                        contact.getPersonalDetail().setEmails(new ArrayList());
                    }
                }
                tmpmail.setEmailType("IMAddress");
                contact.getPersonalDetail().addEmail(tmpmail);
            } else {
            if (emailHome == 0) {
                if (email == 0) {
                    if (contact.getPersonalDetail().getEmails() == null) {
                        contact.getPersonalDetail().setEmails(new ArrayList());
                    }
                }
                tmpmail.setEmailType("Email2Address");
            } else {
                tmpmail.setEmailType("HomeEmail" + (emailHome + 1) + "Address");
            }
            contact.getPersonalDetail().addEmail(tmpmail);
            emailHome++;
            }
        } else if (plist.containsKey("WORK")) {
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            Email tmpmail = new Email(text);
            setParameters(tmpmail,plist,group);
            if (emailWork == 0) {
                if (contact.getBusinessDetail().getEmails() == null) {
                    contact.getBusinessDetail().setEmails(new ArrayList());
                }
                tmpmail.setEmailType("Email3Address");
            } else {
                tmpmail.setEmailType("BusinessEmail" + (emailWork + 1) + "Address");
            }
            contact.getBusinessDetail().addEmail(tmpmail);
            emailWork++;
        } else {
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            Email tmpmail = new Email(text);
            setParameters(tmpmail,plist,group);
            if (email == 0) {
                if (emailHome == 0) {
                    if (contact.getPersonalDetail().getEmails() == null) {
                        contact.getPersonalDetail().setEmails(new ArrayList());
                    }
                }
                tmpmail.setEmailType("Email1Address");
            } else {
                tmpmail.setEmailType("OtherEmail" + (email + 1) + "Address");
            }
            contact.getPersonalDetail().addEmail(tmpmail);
            email++;
        }
  }

  final public void url(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(URL);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        if (!plist.containsKey("HOME") && !plist.containsKey("WORK")) {
            WebPage tmppage = new WebPage();
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            tmppage.setPropertyValue(text);
            setParameters(tmppage,plist,group);

            if (webPage == 0) {
                if (webPageHome == 0) {
                    if (contact.getPersonalDetail().getWebPages() == null) {
                        contact.getPersonalDetail().setWebPages(new ArrayList());
                    }
                }
                tmppage.setWebPageType("WebPage");
            } else {
                tmppage.setWebPageType("WebPage" + (webPage + 1));
            }
            contact.getPersonalDetail().addWebPage(tmppage);
            webPage++;
        }

        if (plist.containsKey("HOME")) {
            WebPage tmppage = new WebPage();
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            tmppage.setPropertyValue(text);
            setParameters(tmppage,plist,group);

            if (webPageHome == 0) {
                if (webPage == 0) {
                    if (contact.getPersonalDetail().getWebPages() == null) {
                        contact.getPersonalDetail().setWebPages(new ArrayList());
                    }
                }
                tmppage.setWebPageType("HomeWebPage");
            } else {
                tmppage.setWebPageType("Home" + (webPageHome + 1) + "WebPage");
            }
            contact.getPersonalDetail().addWebPage(tmppage);
            webPageHome++;
        }

        if (plist.containsKey("WORK")) {
            WebPage tmppage = new WebPage();
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            tmppage.setPropertyValue(text);
            setParameters(tmppage,plist,group);

            if (webPageWork == 0) {
                if (contact.getBusinessDetail().getWebPages() == null) {
                    contact.getBusinessDetail().setWebPages(new ArrayList());
                }
                tmppage.setWebPageType("BusinessWebPage");
            } else {
                tmppage.setWebPageType("Business" + (webPageWork + 1) + "WebPage");
            }
            contact.getBusinessDetail().addWebPage(tmppage);
            webPageWork++;
        }
  }

  final public void tel(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(TEL);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        content=unfold(content);
        content=decode(content,plist.getEncoding(), plist.getCharset());
        content=unescape(content);

        List<String> telPlist=new ArrayList<String>();
        String[] telParameters =
        {
            "PREF",
            "WORK",
            "HOME",
            "VOICE",
            "FAX",
            "MSG",
            "CELL",
            "PAGER",
            "BBS",
            "MODEM",
            "CAR",
            "ISDN",
            "VIDEO"
        };
        for (String parameter : telParameters) {
            if (plist.containsKey(parameter) || parameter.startsWith("X-FUNAMBOL-")) {
                telPlist.add(parameter);
            }
        }

        if (telPlist.contains("WORK")) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone, plist, group);
            // Check if it is the very first for a business detail.
            if ((cellWorkTel == 0) && (voiceWorkTel == 0) &&
                (faxWork == 0) && (pager == 0) && (primary == 0) &&
                (companyMain == 0)) {
                    if (contact.getBusinessDetail().getPhones() == null) {
                        contact.getBusinessDetail().setPhones(new ArrayList());
                    }
            }

            if (telPlist.contains("CELL")) {
                if (cellWorkTel == 0) {
                    tmphone.setPhoneType("MobileBusinessTelephoneNumber");
                } else {
                    tmphone.setPhoneType("MobileBusiness" + (cellWorkTel + 1) + "TelephoneNumber");
                }
                contact.getBusinessDetail().addPhone(tmphone);
                cellWorkTel++;
            }

            if (telPlist.contains("VOICE") || (telPlist.size() == 1)) {
                if (voiceWorkTel == 0) {
                    tmphone.setPhoneType("BusinessTelephoneNumber");
                } else {
                    tmphone.setPhoneType("Business" + (voiceWorkTel + 1) + "TelephoneNumber");
                }
                contact.getBusinessDetail().addPhone(tmphone);
                voiceWorkTel++;
            }
            if (telPlist.contains("FAX")) {
                if (faxWork == 0) {
                    tmphone.setPhoneType("BusinessFaxNumber");
                } else {
                    tmphone.setPhoneType("Business" + (faxWork + 1) + "FaxNumber");
                }
                contact.getBusinessDetail().addPhone(tmphone);
                faxWork++;
            }
            // suppose that can exists only one voice work telephone pref.
            if ((companyMain == 0) && telPlist.contains("PREF")) {
                tmphone.setPhoneType("CompanyMainTelephoneNumber");
                contact.getBusinessDetail().addPhone(tmphone);
                companyMain++;
            }

        } else if ((telPlist.contains("CELL") && telPlist.size() == 1) ||
            (telPlist.contains("CELL") && telPlist.contains("VOICE"))) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone, plist, group);

            if (cellTel == 0) {
                if ((cellHomeTel == 0) && (voiceTel == 0) &&
                    (voiceHomeTel == 0) && (fax == 0)     &&
                    (faxHome == 0) && (car == 0)            ) {
                    if (contact.getPersonalDetail().getPhones() == null) {
                        contact.getPersonalDetail().setPhones(new ArrayList());
                    }
                }
                tmphone.setPhoneType("MobileTelephoneNumber");
            } else {
                tmphone.setPhoneType("Mobile" + (cellTel + 1) + "TelephoneNumber");
            }
            contact.getPersonalDetail().addPhone(tmphone);
            cellTel++;

        } else if (telPlist.contains("HOME") && telPlist.contains("CELL")) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone, plist, group);
            if (cellHomeTel == 0) {
                if ((cellTel == 0) && (voiceTel == 0) &&
                    (voiceHomeTel == 0) && (fax == 0) &&
                    (faxHome == 0) && (car == 0)        ) {
                    if (contact.getPersonalDetail().getPhones() == null) {
                        contact.getPersonalDetail().setPhones(new ArrayList());
                    }
                }
                tmphone.setPhoneType("MobileHomeTelephoneNumber");
            } else {
                tmphone.setPhoneType("MobileHome" + (cellHomeTel + 1) + "TelephoneNumber");
            }
            contact.getPersonalDetail().addPhone(tmphone);
            cellHomeTel++;

        } else if ((telPlist.size() == 1 && telPlist.contains("VOICE")) ||
            (telPlist.size() == 0)) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone,plist,group);
            if (voiceTel == 0) {
                if ((cellTel == 0) && (cellHomeTel == 0) &&
                    (voiceHomeTel == 0) && (fax == 0)    &&
                    (faxHome == 0) && (car == 0)           ) {
                    if (contact.getPersonalDetail().getPhones() == null) {
                        contact.getPersonalDetail().setPhones(new ArrayList());
                   }
                }
                tmphone.setPhoneType("OtherTelephoneNumber");
            } else {
                tmphone.setPhoneType("Other" + (voiceTel + 1) + "TelephoneNumber");
            }
            contact.getPersonalDetail().addPhone(tmphone);
            voiceTel++;

        } else if ((telPlist.contains("VOICE") && telPlist.contains("HOME"))  ||
            (telPlist.size() == 1 && telPlist.contains("HOME"))  )       {
            Phone tmphone = new Phone(content);
            setParameters(tmphone, plist, group);
            if (voiceHomeTel == 0) {
                if ((cellTel == 0) && (cellHomeTel == 0) && (voiceTel == 0) &&
                    (fax == 0) && (faxHome == 0) && (car == 0)               ) {
                    if (contact.getPersonalDetail().getPhones() == null) {
                        contact.getPersonalDetail().setPhones(new ArrayList());
                    }
                }
                tmphone.setPhoneType("HomeTelephoneNumber");
            } else {
                tmphone.setPhoneType("Home" + (voiceHomeTel + 1) + "TelephoneNumber");
            }
            contact.getPersonalDetail().addPhone(tmphone);
            voiceHomeTel++;

        } else if (telPlist.size() == 1 && telPlist.contains("FAX")) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone, plist, group);
            if (fax == 0) {
                if ((cellTel == 0) && (cellHomeTel == 0) && (voiceTel == 0) &&
                    (voiceHomeTel == 0) && (faxHome == 0) && (car == 0)      ) {
                    if (contact.getPersonalDetail().getPhones() == null) {
                        contact.getPersonalDetail().setPhones(new ArrayList());
                    }
                }
                tmphone.setPhoneType("OtherFaxNumber");
            } else {
                tmphone.setPhoneType("Other" + (fax + 1) + "FaxNumber");
            }
            contact.getPersonalDetail().addPhone(tmphone);
            fax++;

        } else if (telPlist.contains("HOME") && telPlist.contains("FAX")) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone,plist,group);
            if (faxHome == 0) {
                if ((cellTel == 0) && (cellHomeTel == 0) && (voiceTel == 0) &&
                    (voiceHomeTel == 0) && (fax == 0) && (car == 0)          ) {

                    if (contact.getPersonalDetail().getPhones() == null) {
                        contact.getPersonalDetail().setPhones(new ArrayList());
                    }
                }
                tmphone.setPhoneType("HomeFaxNumber");
            } else {
                tmphone.setPhoneType("Home" + (faxHome + 1) + "FaxNumber");
            }
            contact.getPersonalDetail().addPhone(tmphone);
            faxHome++;

        } else if (telPlist.contains("CAR")) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone,plist,group);
            tmphone.setPhoneType("CarTelephoneNumber");
            if ((car == 0) && (cellTel == 0) && (cellHomeTel == 0)   &&
                (voiceTel == 0) && (voiceHomeTel == 0) && (fax == 0) &&
                (faxHome == 0)                                         ) {
                if (contact.getPersonalDetail().getPhones() == null) {
                    contact.getPersonalDetail().setPhones(new ArrayList());
                }
            }
            contact.getPersonalDetail().addPhone(tmphone);
            car++;

        } else if (telPlist.contains("PAGER")) {
            Phone tmphone = new Phone(content);
            setParameters(tmphone,plist,group);
            if (pager == 0) {
                if ((cellWorkTel == 0) && (voiceWorkTel == 0)              &&
                    (faxWork == 0) && (primary == 0) && (companyMain == 0)   ) {
                    if (contact.getBusinessDetail().getPhones() == null) {
                        contact.getBusinessDetail().setPhones(new ArrayList());
                    }
                }
                tmphone.setPhoneType("PagerNumber");
            } else {
                tmphone.setPhoneType("PagerNumber" + (pager + 1));
            }
            contact.getBusinessDetail().addPhone(tmphone);
            pager++;

        } else if ((primary == 0) && // suppose that can exists only one voice telephone pref.
            ((telPlist.contains("PREF") && telPlist.contains("VOICE")) ||
            (telPlist.contains("PREF") && telPlist.size() == 1))) {

            Phone tmphone = new Phone(content);
            setParameters(tmphone,plist,group);
            if ((primary == 0) && (cellWorkTel == 0) && (voiceWorkTel == 0) &&
                (faxWork == 0) && (pager == 0) && (companyMain == 0)         ) {
                if (contact.getPersonalDetail().getPhones() == null) {
                    contact.getPersonalDetail().setPhones(new ArrayList());
                }
            }
            tmphone.setPhoneType("PrimaryTelephoneNumber");
            contact.getPersonalDetail().addPhone(tmphone);
            primary++;
        }
  }

  final public void fname(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(FN);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        content=decode(content,plist.getEncoding(), plist.getCharset());
        content=unescape(content);
        contact.getName().getDisplayName().setPropertyValue(content);
        setParameters(contact.getName().getDisplayName(), plist, group);
  }

  final public void role(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(ROLE);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.getBusinessDetail().getRole().setPropertyValue(text);
        setParameters(contact.getBusinessDetail().getRole(), plist, group);
  }

  final public void rev(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(REV);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.setRevision(text);
  }

  final public void nickname(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(NICKNAME);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.getName().getNickname().setPropertyValue(text);
        setParameters(contact.getName().getNickname(),plist,group);
  }

  final public void organization(Token group) throws ParseException {
    ParamList plist  = null            ;
    String content   = null            ;
    FieldsList flist = new FieldsList();
    String encoding  = null            ;
    jj_consume_token(ORG);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        flist.addValue(content);

        int pos;  // Position in tlist (i.e. position of the current value field)

        // Organization Name
        pos = 0;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getBusinessDetail().getCompany().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getCompany(), plist, group);
        }

        // Organizational Unit
        pos = 1;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getBusinessDetail().getDepartment().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getDepartment(), plist, group);
        }
  }

  final public void address(Token group) throws ParseException {
    ParamList plist  = null            ;
    String content   = null            ;
    FieldsList flist = new FieldsList();
    jj_consume_token(ADR);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        flist.addValue(content);

        int pos;  // Position in tlist (i.e. position of the current value field)
        String text;

        if (plist.containsKey("WORK")) {
        // Business Address

            addressWork++;

            //Post Office Address
            pos = 0;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getPostOfficeAddress().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getPostOfficeAddress(), plist, group);

            // Extended Address
            pos = 1;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getExtendedAddress().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getExtendedAddress(), plist, group);

            // Street
            pos = 2;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getStreet().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getStreet(), plist, group);

            // Locality
            pos = 3;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getCity().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getCity(), plist, group);

            // Region
            pos = 4;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getState().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getState(), plist, group);

            // Postal Code
            pos = 5;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getPostalCode().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getPostalCode(), plist, group);

            // Country
            pos = 6;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getBusinessDetail().getAddress().getCountry().setPropertyValue(text);
            setParameters(contact.getBusinessDetail().getAddress().getCountry(), plist, group);
        }

        if (plist.containsKey("HOME")) {
        // Home Address

            addressHome++;

            //Post Office Address
            pos = 0;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getPostOfficeAddress().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getPostOfficeAddress(), plist, group);

            // Extended Address
            pos = 1;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getExtendedAddress().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getExtendedAddress(), plist, group);

            // Street
            pos = 2;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getStreet().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getStreet(), plist, group);

            // Locality
            pos = 3;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getCity().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getCity(), plist, group);

            // Region
            pos = 4;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getState().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getState(), plist, group);

            // Postal Code
            pos = 5;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getPostalCode().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getPostalCode(), plist, group);

            // Country
            pos = 6;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getAddress().getCountry().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getAddress().getCountry(), plist, group);
        }

        // other address
        if (!plist.containsKey("HOME") && !plist.containsKey("WORK")) {
        // Other Address

            addressOther++;

            //Post Office Address
            pos = 0;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getPostOfficeAddress().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getPostOfficeAddress(), plist, group);

            // Extended Address
            pos = 1;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getExtendedAddress().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getExtendedAddress(), plist, group);

            // Street
            pos = 2;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getStreet().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getStreet(), plist, group);

            // Locality
            pos = 3;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getCity().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getCity(), plist, group);

            // Region
            pos = 4;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getState().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getState(), plist, group);

            // Postal Code
            pos = 5;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getPostalCode().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getPostalCode(), plist, group);

            // Country
            pos = 6;
            if (flist.size()>pos) {
                text=unfold(flist.getElementAt(pos));
                text=decode(text,plist.getEncoding(), plist.getCharset());
            } else {
                text="";
            }
            contact.getPersonalDetail().getOtherAddress().getCountry().setPropertyValue(text);
            setParameters(contact.getPersonalDetail().getOtherAddress().getCountry(), plist, group);
        }
  }

  final public void birthday(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(BDAY);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        String birthday = text;

        try {
            birthday = TimeUtils.normalizeToISO8601(birthday, defaultTimeZone);
            contact.getPersonalDetail().setBirthday(birthday);
        } catch (Exception e) {
            //
            // If the birthday isn't in a valid format
            // (see TimeUtils.normalizeToISO8601), ignore it
            //
        }
  }

  final public void label(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(LABEL);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        if (plist.containsKey("WORK")) {
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            if (plist.containsKey("X-FUNAMBOL-PRESERVE")
                    && !(("0").equals(plist.getValue("X-FUNAMBOL-PRESERVE")))) {
                contact.getBusinessDetail().getAddress().getLabel().setPropertyValue(text);
                setParameters(contact.getBusinessDetail().getAddress().getLabel(), plist, group);
            } else if (addressWork == 0) {
                contact.getBusinessDetail().getAddress().explodeLabel(text);
            }
        }
        if (plist.containsKey("HOME")) {
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            if (plist.containsKey("X-FUNAMBOL-PRESERVE")
                    && !(("0").equals(plist.getValue("X-FUNAMBOL-PRESERVE")))) {
                contact.getPersonalDetail().getAddress().getLabel().setPropertyValue(text);
                setParameters(contact.getPersonalDetail().getAddress().getLabel(), plist, group);
            } else if (addressHome == 0) {
                contact.getPersonalDetail().getAddress().explodeLabel(text);
            }
        }
        if (!plist.containsKey("HOME") && !plist.containsKey("WORK")) {
            String text=unfold(content);
            text=decode(text,plist.getEncoding(), plist.getCharset());
            text=unescape(text);
            if (plist.containsKey("X-FUNAMBOL-PRESERVE")
                    && !(("0").equals(plist.getValue("X-FUNAMBOL-PRESERVE")))) {
                contact.getPersonalDetail().getOtherAddress().getLabel().setPropertyValue(text);
                setParameters(contact.getPersonalDetail().getOtherAddress().getLabel(), plist, group);
            } else if (addressOther == 0) {
                contact.getPersonalDetail().getOtherAddress().explodeLabel(text);
            }
        }
  }

  final public void timezone(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(TZ);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.setTimezone(text);
  }

  final public void logo(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(LOGO);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.getBusinessDetail().getLogo().setPropertyValue(text);
        setParameters(contact.getBusinessDetail().getLogo(), plist, group);
  }

  final public void note(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(NOTE);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        Note tmpnote = new Note();
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        tmpnote.setPropertyValue(text);
        setParameters(tmpnote, plist, group);

        note++;
        if (note == 1) {
            if (contact.getNotes() == null) {
                contact.setNotes(new ArrayList());
            }
            tmpnote.setNoteType("Body");
        } else {
            tmpnote.setNoteType("Body" + note);
        }
        contact.addNote(tmpnote);
  }

  final public void uid(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(UID);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.setUid(text);
  }

  final public void photo(Token group) throws ParseException {
    ParamList plist  = null            ;
    String content   = null            ;
    FieldsList flist = new FieldsList();
    jj_consume_token(PHOTO);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text,plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.getPersonalDetail().getPhoto().setPropertyValue(text);
        setParameters(contact.getPersonalDetail().getPhoto(), plist, group);
        if (plist != null) {
            contact.getPersonalDetail().getPhoto().setType(plist.getValue("TYPE"));
        }
  }

  final public void name(Token group) throws ParseException {
    ParamList plist  = null            ;
    String content   = null            ;
    FieldsList flist = new FieldsList();
    jj_consume_token(N);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        flist.addValue(content);

        int pos;  // Position in tlist (i.e. position of the current value field)

        // Last name
        pos=0;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getName().getLastName().setPropertyValue(text);
            setParameters(contact.getName().getLastName(), plist, group);
        }
        // First name
        pos=1;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getName().getFirstName().setPropertyValue(text);
            setParameters(contact.getName().getFirstName(), plist, group);
        }
        // Middle name
        pos=2;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getName().getMiddleName().setPropertyValue(text);
            setParameters(contact.getName().getMiddleName(), plist, group);
        }
        // Prefix
        pos=3;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getName().getSalutation().setPropertyValue(text);
            setParameters(contact.getName().getSalutation(), plist, group);
        }
        // Suffix
        pos=4;
        if (flist.size() > pos) {
            String text=unfold(flist.getElementAt(pos));
            text=decode(text,plist.getEncoding(), plist.getCharset());
            contact.getName().getSuffix().setPropertyValue(text);
            setParameters(contact.getName().getSuffix(), plist, group);
        }
  }

  final public void folder(Token group) throws ParseException {
    ParamList plist = null;
    String content  = null;
    jj_consume_token(FOLDER);
    plist = params();
    colon();
    content = text();
    jj_consume_token(EOL);
        String text=unfold(content);
        text=decode(text, plist.getEncoding(), plist.getCharset());
        text=unescape(text);
        contact.setFolder(text);
  }

// --------------------------- SERVICE BNF EXPANSIONS --------------------------

/**
 * Parses property parameters and returns a ParamList with the generated Tokens.
 * Example: in TEL;WORK;VOICE;CHARSET=ISO-8859-8:+1-800-555-1234 will parse the
 * ";WORK;VOICE;CHARSET=ISO-8859-8:" part and return a list containing "WORK"
 * and "VOICE" as types, and "ISO-8859-8" as charset.
 *
 * @return the list of parameters
 */
  final public ParamList params() throws ParseException {
    ParamList paramList = new ParamList();
    Token paramName = null, paramValue = null;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
      case SEMICOLON_QP:
      case QUOTED_PRINTABLE:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
      case SEMICOLON_QP:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        case SEMICOLON_QP:
          jj_consume_token(SEMICOLON_QP);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        paramName = jj_consume_token(PARAMSTRING);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUAL:
          jj_consume_token(EQUAL);
          paramValue = jj_consume_token(PARAMSTRING);
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
            paramList.add(paramName.image, (paramValue == null) ? null : paramValue.image);
        break;
      case QUOTED_PRINTABLE:
        jj_consume_token(QUOTED_PRINTABLE);
            paramList.add("ENCODING", "QUOTED-PRINTABLE");
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses the fields of a property value and returns a StringBuffer with text after ":".
 * The single element comma separated are retrieved by function in FieldsList class
 *
 * @return the list of fields
 */
  final public String text() throws ParseException {
    Token t = null;
    StringBuffer sb = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEOL:
    case SEOL_QP:
    case CONTENTSTRING:
    case CONTENTSTRING_QP:
    case NONBREAKINGEQUALS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEOL:
      case CONTENTSTRING:
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEOL:
            jj_consume_token(SEOL);
            break;
          case CONTENTSTRING:
            t = jj_consume_token(CONTENTSTRING);
                            sb.append(t.image);
            break;
          default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEOL:
          case CONTENTSTRING:
            ;
            break;
          default:
            jj_la1[15] = jj_gen;
            break label_6;
          }
        }
        break;
      case SEOL_QP:
      case CONTENTSTRING_QP:
      case NONBREAKINGEQUALS:
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEOL_QP:
            jj_consume_token(SEOL_QP);
            break;
          case CONTENTSTRING_QP:
            t = jj_consume_token(CONTENTSTRING_QP);
                                sb.append(t.image);
            break;
          case NONBREAKINGEQUALS:
            t = jj_consume_token(NONBREAKINGEQUALS);
                                 sb.append(t.image);
            break;
          default:
            jj_la1[16] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEOL_QP:
          case CONTENTSTRING_QP:
          case NONBREAKINGEQUALS:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_7;
          }
        }
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
         {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public void colon() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      break;
    case COLON_QP:
      jj_consume_token(COLON_QP);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(CATEGORIES)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_scan_token(EMAIL)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(REV)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(TEL)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(LABEL)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(NOTE)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(ADR)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(QUOTED_PRINTABLE)) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(ROLE)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_12() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_11() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_10()) {
    jj_scanpos = xsp;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_10() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(N)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(LOGO)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(8)) return true;
    }
    return false;
  }

  private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_scan_token(TITLE)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(BDAY)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_56()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_scan_token(FN)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(TZ)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_8() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(1)) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(VERSION)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(PHOTO)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_8()) jj_scanpos = xsp;
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_scan_token(ORG)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(FOLDER)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(EXTENSION)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_scan_token(UID)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) return true;
    }
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(NICKNAME)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(URL)) return true;
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public VcardParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[21];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x4,0x4,0x4,0x4,0x7ffffc00,0x4,0x4,0x0,0x0,0x7ffffc00,0x180,0x180,0x200,0x180,0x8,0x8,0x10,0x10,0x18,0x18,0x60,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x20,0x20,0x20,0x20,0x102,0x20,0x20,0x100,0x100,0x2,0x40,0x0,0x0,0x40,0x4,0x4,0x18,0x18,0x1c,0x1c,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public VcardParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public VcardParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new VcardParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public VcardParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new VcardParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public VcardParser(VcardParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(VcardParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[41];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 21; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 41; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
